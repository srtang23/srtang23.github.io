<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, maximum-scale=1.0" />

    <title>Sophia's HCDE 439 Physical Computing Page!</title>

    <link href="style.css" rel="stylesheet" type="text/css" />
    <script src="app.js"></script>
  </head>
  <body>
    <div class="back-button">
      <a href="index.html">Back</a>
    </div>
    <h1>A4: Libraries</h1>

    <div class="subsection">
      <h2>Schematic</h2>
      <img src="images/schematic_a4.jpeg">
      <p>
        This schematic shows how the Arduino is connected to the keypad and LCD for my password-based lock system.
        The 4x3 keypad connects its rows to pins 7, 6, A0, and A1, and its columns to pins A2-A4,
        leaving out the unused C4 column from the keypad (so it's 4x3).
        The 16x2 LCD is wired in 4-bit mode, with D4-D7 going to pins 2-5,
        and RS and E connected to pins 12 and 11.
        The V0 pin has a 2k Ω resistor connected to ground to adjust text brightness,
        and a 220 Ω resistor is used between the LCD's backlight anode and 5 V to limit current
        and control the backlight. Everything shares the same 5 V and ground.
        The values of the resistors were chosen by testing with different resistor ranges,
        and these two provided the best results for display contrast and backlight brightness.
    </div>

    <div class="subsection">
      <h2>Circuit</h2>
      <div class="circuit-images">
        <img src="images/circuit_a4.png">
        <p>
          This circuit shows the full wiring setup of Arduino for my password-based lock system.
          The 4x3 keypad on the left is connected to digital pins A0-A4 and pins 6-7 on the Arduino,
          which are used to detect key presses. The 16x2 LCD on the right is wired to digital pins 2-5,
          11, and 12 using the LiquidCrystal setup. A 10 kΩ potentiometer adjusts the screen contrast,
          and a 220 Ω resistor controls the backlight brightness. The keypad acts as the input for entering the password,
          while the LCD acts as an output that provides live feedback, including showing prompts,
          asterisks for entered digits, and countdown messages during the lockout period.
        </p>
      </div>

      <img src="images/circuit_operation_a4.GIF">
      <p>
        This project uses the <code>LiquidCrystal</code> and <code>Keypad</code>
        libraries to replicate a password-based lock system.
        The LCD prompts “ENTER PASSWORD” and waits for # to start.
        After entering the 4-digit code, it checks whether it matches the preset password;
        if not, you have up to three tries before the system locks for 10 seconds,
        displaying a countdown on the screen before resetting the failed attempts.
      </p>
    </div>

    <div class="subsection">
      <h2>Firmware</h2>
      <a href="arduino/a4_libraries/a4_libraries.ino">Arduino Sketch for A4 Libraries</a>
      <pre><code id="code-block">#include &lt;Keypad.h&gt; // library to read input from keypad
#include &lt;LiquidCrystal.h&gt; // library to control LCD display

const byte ROWS = 4; // four rows
const byte COLS = 3;    // three columns

// define the cymbols on the buttons of the keypads
char keys[ROWS][COLS] = {
  {'1','2','3'},
  {'4','5','6'},
  {'7','8','9'},
  {'*','0','#'}
};

// connect keypad row and column pins to Arduino pins
byte rowPins[ROWS]={7, 6, A0, A1};
byte colPins[COLS]={A2, A3, A4};

// initialize keypad and LCD objects
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
LiquidCrystal lcd(12, 11, 5, 4, 3, 2);


const char CODE[] = "4826"; // correct password
int inputLen = 0; // records number of digits entered
int failCount = 0; // counts failed attempts
const int MAX_FAILS = 3; // 3 incorrect tries before lockout
const unsigned long LOCKOUT_MS = 10000; // 10 seconds lockout time
unsigned long lockedUntil = 0; // stores when lockout ends

// clear and print two lines on LCD with two input parameters
void displayScreen(const char* line1, const char* line2 = "") {
  lcd.clear(); // clear previous text
  // set cursor to first line and print first message
  lcd.setCursor(0,0);
  lcd.print(line1);

  // set cursor to second line and print second message
  lcd.setCursor(0,1);
  lcd.print(line2);
}

void setup() {
  lcd.begin(16, 2); // initialize LCD (16 cols x 2 rows)
  displayScreen(" ENTER PASSWORD", "Press # to start"); // set up default screen
}

void loop() {
  // system starts only when user presses #
  if (keypad.getKey() == '#') {
    char* inputs = getInput(); // retrieve inputs

    // check if code is correct
    if (isCorrect(inputs)) {
      failCount = 0; // reset failed attempts
      displayScreen(" ACCESS GRANTED", "    UNLOCKED"); // display unlocked message on screen
      delay(800); // short delay before reset

    } else { // incorrect attempt
      failCount++; // increment failed attempt count by 1

      // if attempts are still under max limit
      if (failCount < MAX_FAILS) {
        displayScreen("  ACCESS DENIED", "   Try again"); // display error message
        delay(800); // short delay

      } else { // reach the max fail attempts
        lockedUntil = millis() + LOCKOUT_MS; // set unlock time as 10 sec later
        displayScreen("   LOCKED OUT", "Too many tries"); // display lockout message

        // while 10 seconds isn't up
        while (millis() < lockedUntil) {
          lockoutCountdown(); // show countdown
          delay(200); // update every .2 seconds
        }
        failCount = 0;  // reset fails after timeout
      }

    // reset input length and display screen
    reset();
    }
  }

}

// reads 4 digits from keypad input and returns that input
char* getInput() {
  inputLen = 0; // reset input length to 0
  static char inputs[4]; // store up to 4 characters
  lcd.clear(); // clear previous text
  lcd.print(" ENTER PASSWORD"); // display input prompt
  lcd.setCursor(0, 1); // go to second line
  lcd.print("      ");  // just spacing for centered text

  // loop until all 4 digits have been entered
  while (inputLen < 4) {
    char key = keypad.getKey(); // read key press
    if (key) { // only process valid key press
      inputs[inputLen] = key; // store the key in the array
      inputLen++; // update numbers of digits entered
      lcd.print("*"); // show * for each digit entered
    }
  }
  return inputs; // return the input
}

// checks if the entered digits match the correct CODE
bool isCorrect(char inputs[]) {
  // loop through all digits entered
  for (int i = 0; i < inputLen; i++) {
    // if any digit doesn't match, return false
    if (inputs[i] != CODE[i]) {
      return false;
    }
  }
  // otherwise, return true
  return true;
}

// displays countdown timer while system is locked
void lockoutCountdown() {
  long timeRemaining = (long)(lockedUntil - millis()); // calculate remaining time
  int secs = (timeRemaining + 999) / 1000; // convert to seconds
  lcd.setCursor(0, 1); // move to second line

  // print remaining seconds
  lcd.print("  Retry in ");
  lcd.print(secs);
  lcd.print("s   ");
}

// resets everything to the start screen
void reset() {
  inputLen = 0; // clear number of entered digits
  displayScreen(" ENTER PASSWORD", "Press # to start"); // show starting message
}</code></pre>
      <p><i>
        * Some parts of the code were adapted from the built-in <code>LiquidCrystal</code>
        and <code>Keypad</code> library examples.
      </i></p>

    </div>

    <div class="subsection">
      <h2>Questions</h2>
      <ol>
        <div>
          <strong><li>
            Say you are using a servo motor you attach to pin 9. In your loop() you have the following code:
            <pre><code>
void loop() {
for (pos = 0; pos <= 180; pos += 1) {
  myservo.write(pos);
  delay(100);
  }
}
          </code></pre>
          Draw a graph with the x-axis as time and the y-axis as voltage at pin 9 with respect to ground.
          </li></strong>
          <img src="images/voltage_time_graph_a4.jpeg" class="graph">
          <p>
            The signal is a pulse train repeating every 20 ms (50 Hz),
            with each pulse briefly rising to 5 V before dropping back to 0 V.
            The pulse width varies between 1 ms and 2 ms, corresponding to the servo's position:
            about 0° at 1 ms, 90° at 1.5 ms (center), and 180° at 2 ms.
            Within the first 80 ms shown,
            the pulse widens slightly from 1 ms to about 1.2 ms (it would be hard to tell the difference in the graph).
          </p>
        </div>

        <div>
          <strong><li>
            Your input device is slightly broken, leading it to give us an erroneous reading 1% of the time.
            How can we address this? Answer in (pseudo)code.
          </li></strong>
          <pre><code>
Initialize count to 0
Initialize an integer array readings that can hold 10 values

While count is less than 10:
  Take a new reading from the input device and append it to readings
  Increment count by 1

Sort readings from smallest to largest
Compute the median by getting readings[count / 2]

Return the median
          </code></pre>
        </div>

        <div>
          <strong><li>
            Your input device is slightly noisy,
            leading the measurement to randomly deviate from the true measurement up or down by 10%.
            How can we address this? Answer in (pseudo)code.
          </li></strong>
          <pre><code>
// helper method to compute the average of multiple sensor readings

Initialize totalReadings to 0
Initialize an integer array readings that can hold 10 values
Initialize prevInput to the first reading from the input device

For each int reading in readings:
  Take a new reading from the input device and store it as currInput

    If currInput is greater than 2.5 times prevInput:
        Set currInput to prevInput

    Set reading to currInput
    Add currInput to totalReadings
    Set prevInput to currInput

Compute the average as totalReadings divided by 10
Return the average
          </code></pre>
        </div>

      </ol>
    </div>
  </body>
</html>